pub module animals

pub trait Animal {
	pub name string
	pub age uint32
}

pub func makeNoise(animal *Animal)

pub struct Dog {
	Animal
	pub tag string
}

pub struct Cat {
	Animal
	pub breed string
}

pub func makeNoise(dog *Dog) {
	printLine("woof")
}

pub func makeNoise(cat *Cat) {
	printLine("meow")
}

pub func main() {
	var pet mut *Animal = &Dog()
	makeNoise(pet)
	pet = &Cat()
	pet->makeNoise()
}




struct Color {
	r, g, b uint8
} cases {
	default struct Rgb
	red = (255,0,0)
	green = (0,255,0)
	blue = (0,0,255)
}

func maybeError() union[int32, MyError]

func combineInterfaces(x *product[Animal, Noisy])

func generic[T type](x T)

func sqrt(x float64) (pos, neg float64)

var tuple (int32, string)




inline func max(a _, b _) _ {
	return a if a >= b else b
}

inline func twice(inline x _) {
	printLine(x)
	printLine(x) // evaluates x a second time
}

inline var length int32 = 1
var array [length]int32

func sinTable(result []mut float64) {
	for i in 0 until result.length {
		result[i] = math.sin(math.pi/i)
	}
}
var table [1024]float64
inline sinTable(&table) // Generate the table at compile time.




// you can disable the compiler inserting checks on frees which makes forgets compile to no ops.
// forget decreases the allocator's internal pointer count and marks a bool in the stack frame of the thing you're forgetting.
// you can only forget entire slices or arrays, not just one element.

// lifetime safety is accomplished through ref counting.
// dropping an allocator before its allocations are freed is a runtime error.
// you must forget an allocation if you don't want to drop it.
// forget compiles to noop in release builds.


owned *int32 // not allowed to dangle
weak *int32 // not allowed to dangle
*int32 // not allowed to dangle
raw *int23 // allowed to dangle


struct Block {
	next *Block
	size uint32
	strongCount uint16
	weakCount uint16
	// these two are not present in release builds:
	normalCount uint16
	rawCount unt16
}


var heap mut = BlockAllocator(1024)
var a owned *int32 = new 1 in heap
drop a from heap
drop heap


var heap mut = BlockAllocator(1024)
var a owned *int32 = new 1 in heap
forget a from heap
drop heap


var heap mut = BlockAllocator(1024)
var a owned *int32 = new 1 in heap
var b owned *int32 = move a
drop b from heap
drop heap


var heap mut = BlockAllocator(1024)
var a owned *int32 = new 1 in heap
var b weak *int32 = a
drop a, b from heap
drop heap


struct Foo {
	x owned *int32
}

func make() using(allocator *Allocator) Foo {
	return Foo(x=new int32 in allocator)
}

func drop(foo *Foo) using(allocator *Allocator) {
	drop foo.x from allocator
}

func forget(foo *Foo) using(allocator *Allocator) {
	forget foo.x from allocator
}

var heap mut = BlockAllocator(1024)
var foo = Foo() using heap
drop foo using heap
drop heap

var heap mut = BlockAllocator(1024)
var foo = new Foo() in heap using heap
drop foo from heap using heap
drop heap

var heap mut = BlockAllocator(1024)
var foo = new Foo() in heap using heap
forget foo using heap
drop heap


func gameLoop() {
	var scratch mut = StackAllocator(1024*10)
	while true {
		freeAll(&scratch)
		// allocate something in scratch
	}
}


module globalAllocations

var heap mut BlockAllocator
var ptr owned *int32

// special function
func initialize() {
	heap = BlockAllocator(1024)
	ptr = new 1 in heap
}

// special function
func deinitialize() {
	drop ptr from heap
	drop heap
}

// special function
func main() {
	printLine(*ptr)
}
