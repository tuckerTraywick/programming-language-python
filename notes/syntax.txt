1 as Int32->f()   (1 as Int32)->f()
1->f() as Int32   (1->f()) as Int32
f as Callback(x)

. () []
->
* & + - ~
as  // Doesn't care about precedence for rhs since it parses a type and not an expression.

*x->f()   *(x->(f()))
a.b->f()   (a.b)->(f())
*x as Int32   (*x) as Int32
x->f() as Int32   (x->(f())) as Int32
x as Int32->f()   (x as Int32)->f()

Maybe<Owned<&Int32>>





pub var a Int32 = 1






// compilation units specify namespaces they depend on.
// source files don't have to import things unless they want to shorten a name.
// you cannot assign functions. to alias a function, do a using statement.

// myProject/package.txt
version 1.0.0
subpackages {
	pakageName {
		namespace1
		namespace2
	}
}
dependencies {
	std.io
	std.math
	somePackage
}

using std.io
using std.io.*
using std.io
	.printLine,
	.inputLine
using myIo = std.io // explicit export.
pub using std.io.* // export All.
pub using myPrint = std.io.printLine // explicit function export.
pub using myPi = std.math.pi // same variable with same address.
pub var myPi = std.math.pi // different var with different address.

using BigInt = Int64 // is not a distinct type.

struct UserID = UInt32 // is a distinct type.

struct Color {
	r, g, b UInt8
} cases {
	default struct Rgb
	red = (255, 0, 0)
	green = (0, 255, 0)
	blue = (0, 0, 255)
}

struct Direction = UInt8 cases {
	north
	south
	east
	west
}

var tuple (x Int32, y String) = (1, "a")
var tuple = (1, "a") as (x Int32, y String)
var array [10]Int32 = [1, 2, 3]
var array = [1, 2, 3] as [10]Int32
new([] as [10]Int32) using heap
new((1, "a") as (Int32, String))

Maybe Int32
Any<Int32, MyError>
All<File, Readable>
Owned &Int32
Weak &Int32
Raw &Int32
Mutex Int32




struct Foo {
	x Owned &Int32
}
func make() Any<Foo, AllocationError> {
	return Foo(new(1))
}

var heapA = BlockAllocator(1024)
var heapB = StackAllocator(1024)
var foo Owned &Foo = new(Foo() using heapA) using heapB
drop(*foo) using heapA
drop(foo) using heapB

using var Allocator = BlockAllocator(1024)
var foo = new(Foo())



pub namespace animals
using std.io.printLine

pub trait Animal {
	pub name String
	pub age UInt32
}

pub method makeNoise(animal &Animal)

pub struct Dog {
	using Animal
	pub tag String
}

pub struct Cat {
	using Animal
	pub breed String
}

pub func makeNoise(dog &Dog) {
	printLine("woof")
}

pub func makeNoise(cat &Cat) {
	printLine("meow")
}

pub func main() {
	var pet mut &Animal = &Dog()
	makeNoise(pet)
	pet = &Cat()
	pet->makeNoise()
}




pub namespace physics

pub struct Entity {
	pub pos, vel, acc Vector
} cases {
	struct Circle {pub radius Float64}
	struct Mesh {pub vertices Owned []Vector}
}

pub method update(entity &mut Entity)

pub struct Vector {
	using std.operations.To<String>, .Equality, .Arithmetic
	pub x, y Float64
}

pub func to<String>(vector &Vector) {
	return new(f"({vector.x}, {.y})")
}




pub namespace shapes
using std.math.pi
using std.io.printLine

pub struct Shape cases {
	struct Circle {pub radius Float64}
	struct Triangle {pub base, height Float64}
	struct Rectangle {pub width, height Float64}
}

pub method area(shape &Shape) Float64

pub func area(circle &Circle) {
	return pi*circle.radius*circle.radius
}

pub func area(triangle &Triangle) {
	return 0.5*triangle.base*triangle.height
}

pub func area(rectangle &Rectangle) {
	return rectangle.width*rectangle.height
}

pub func main() {
	var shape mut Shape = Circle(1)
	printLine(area(&circle))
	shape = Triangle(2, 3)
	printLine(shape->area())
	shape = Rectangle(4, 5)
	printLine(shape->area())
}




pub namespace compiler

pub struct TokenType = UInt8 cases {
	number
	character
	str
	identifier
	
	namespace_
	...
}

pub struct Token {
	pub type TokenType
	pub textStart Index<Char, UInt32>
	pub textLength UInt32
}

pub struct LexerErrorType = String cases {
	invalidToken = "Invalid token."
	...
}

pub struct LexerError {
	using Error
	pub type LexerErrorType
	pub tokenIndex Index<Token, UInt32>
	pub textStart Index<Char, UInt32>
	pub textLength UInt32
}

pub struct LexerResult {
	pub tokens Maybe Owned []Token
	pub errors Maybe Owned []LexerError
}

pub func lex(text String) LexerResult


pub namespace compiler

pub struct NodeType = UInt8 cases {
	program
	...
}

pub struct Node {
	pub type NodeType
	pub next NodeOrToken
	pub child NodeOrToken
}

pub struct NodeOrToken = Any<Index<Node, UInt32>, Index<Token, UInt32>>

pub struct ParserErrorType = String cases {
	expectedIdentifier = "Expected an identifier."
	...
}

pub struct ParserError {
	using Error
	pub type ParserErrorType
	pub treeStart NodeOrToken
	pub treeLength UInt32
}

pub struct ParserResult {
	pub nodes Owned []NodeOrToken
	pub errors Owned []ParserError
}

pub func parse(tokens []Token) ParserResult
