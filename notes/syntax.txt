Structural typing? Would solve the ugly cases A... syntax. Would also eliminate the need to
distinguish between structs and traits. Only exception to structural typing would be methods.

() for construction and tuples
[] for indexing and generics

(int32, string)(1, "a") # Tuple
[10]int32(1, 2, 3, [...9] = 0) # Array
[string]int32(["a"] = 1, ["b"] = 2) # Map
Dog(name = "fido") # Object
LinkedList[int32](1, 2, 3) # Generic
type{a int32, b string}(1, "a") # Anonymous type
cases{int32, string}(1) # Anonymous union
func(x int32) int32 => x + 1 # Anonymous function




type Color {
	r, g, b uint8
} cases {
	red = (255, 0, 0)
	green = (0, 255, 0)
	blue = (0, 0, 255)
}


func resultType() cases{int32, error}

func combineInterfaces(x *type{Equality, Arithmetic, To[string]})

func namedReturnValues() type{a int32, b string}




pub package a

pub type ThingA {
	pub x int32
}

pub package b

pub type ThingB {
	pub x int32
}

pub func foo(b *ThingB) {}

pub package main
import {
	a
	b
}

pub func main() {
	b.foo(a.ThingA())
}




pub package animals
import {
	std.io.*
}

pub type Animal {
	pub name string
	pub age uint32
}

pub method makeNoise(animal *Animal)

pub type Dog {
	Animal
	pub tag string
}

pub type Cat {
	Animal
	pub breed string
}

pub func makeNoise(dog *Dog) {
	printLine("woof")
}

pub func makeNoise(cat *Cat) {
	printLine("meow")
}

pub func main() {
	var pet mut *Animal = &Dog()
	makeNoise(pet)
	pet = &Cat()
	pet->makeNoise()
}


pub package moreAnimals
import {
	std.io.*
	animals.*
}

pub type Pet {
	Animal
}

pub method walk(pet *Pet)

pub type Hamster {
	Pet
}

pub func makeNoise(hamster *Hamster) {
	printLine("squeak")
}

pub func walk(hamster *Hamster) {}

pub func walk(dog *Dog) {}

pub func walk(cat *Cat) {}




pub package physics
import {
	std.operations
}

pub type Entity {
	pub position, velocity, acceleration
} cases {
	type Circle {
		pub radius float64
	}

	type Mesh {
		pub vertices []Vector
	}
}

pub type Vector {
	std.operations.To[string], .Equality, .Arithmetic
	pub x, y float64
}

pub func collide(a, b *mut Entity) {
	switch *a, *b {
		case Circle, Circle:
		case Mesh, Mesh:
		case Circle, Mesh:
		case Mesh, Circle:
	}
}

pub func std.operations.to[string](vector *Vector) string {
	return f"({vector.x}, {vector.y})"
}




pub package lexer

pub type Token {
	pub type TokenType
	pub text string
}

pub type TokenType cases {
	invalidToken
	number
	identifier
	keyword
	operator
}

pub func lex(text string) owned []mut Token


pub package parser
import {
	lexer.*
}

pub type Tree {
	nodes owned []mut Node
}

pub type Node {
	pub type NodeType
	pub child *Node
	pub sibling *Node
}

pub type NodeType cases {
	invalidSyntax
	program
	packageStatement
	...
}

// Uses the default implementation.
pub func *nodes(tree *Tree) *[]Node

pub func parse(tokens []Token) Node




package numberGuesser
import {
	std.io.printLine, .inputLine
	std.math.random
}

pub func main() {
	printLine("I'm thinking of a number between 1 and 100. What is it?\n")
	var number = random[int32](1, 100)
	while true {
		var guessString = inputLine("guess: ")
		var guess cases{uint32, error} = guessString->to[uint32]()
		
		if guess is not int32 {
			printLine("Enter a number between 1 and 100.")
		} else if guess == number {
			printLine("Correct! You win!")
			break
		} else {
			printLine("Incorrect. Guess again.")
		}
	}
}




pub package shapes
import {
	std.io.printLine
	std.math.pi, .pow
}

pub type Shape cases {
	type Circle {
		pub radius float64
	}

	type Triangle {
		pub base, height float64
	}

	type Rectangle {
		pub width, height float64
	}
}

pub method area(shape *Shape) float64

pub func area(circle Circle) float64 {
	return pi*pow(circle.radius, 2)
}

pub func area(triangle Triangle) float64 {
	return 0.5*triangle.base*triangle.height
}

pub func area(rectangle Rectangle) float64 {
	return rectangle.width*rectangle.height
}

pub func main() {
	var shape mut Shape = Circle()
	printLine(area(shape))
	shape = Rectangle()
	printLine(shape->area())
}




package chess

type Board = [8][8]char

var keepRunning mut = true
var turn uint32 mut

pub func main() {
	var board mut Board
	setupBoard(&board)
	printWelcomeMessage()
	while keepRunning {
		printTurnMessage()
	}
}



type Node {
	type NodeType
	children []any[Node, Token]
}

type ParseResult = any[Node, Token, none]

func match(type, text) {
	func parse(tokens, index) {
		
	}
}
